Commerce Forge — это компактный пример «магазина в микросервисах». Здесь можно потренироваться в работе с RabbitMQ, EF Core и контейнерами, не распаковывая многотомные проекты.

Первый сервис, SalesHandler, принимает заказ и отправляет сообщение в очередь.
Второй, BillingHandler, слушает очередь, списывает оплату и пишет результат в Postgres.
Третий, EdgeGateway, проксирует оба API наружу через YARP, чтобы внешний клиент видел их как единое приложение.

Инфраструктура стандартная: PostgreSQL 15 для данных, RabbitMQ 3-management для обмена сообщениями, всё запускается в Docker-Compose. Нужна одна команда:

bash
Копировать
Редактировать
docker compose up --build
После старта сервисы доступны по Swagger-UI:

Сервис	URL

Покупки	http://localhost:5050/swagger

Платежи	http://localhost:5001/swagger

Шлюз	http://localhost:8080/swagger

RabbitMQ UI	http://localhost:15672

При запуске контейнеры сами применят миграции EF Core, поэтому БД готова без ручных команд. Пароли и ключи в файлах — демонстрационные; поменяйте их перед реальным деплоем.

В репозитории только исходники: каталоги bus, handlers, persistence, .gitignore отсекает bin/, obj/ и файлы IDE. Лицензия MIT. Если найдёте, что улучшить, присылайте PR — главное, чтобы dotnet build и docker compose up --build проходили без ошибок

Реализованные фишки на 8

Первое — функциональная полнота при минимальном наборе кода. Commerce Forge демонстрирует рабочий цикл e-commerce: заказ → событие → оплата, причём каждый шаг оформлен отдельным сервисом и связан через RabbitMQ. Запуск «одной кнопкой» в Docker-Compose подтверждает, что система жизнеспособна целиком, без ручных правок и «магии» в терминале.

Второе — чистая, легко читаемая архитектура. Каталоги bus, handlers, persistence чётко разделяют зоны ответственности, а короткие имена файлов делают навигацию мгновенной

Третье — готовность к расширению и демонстрационный комфорт. Swagger-UI на каждом сервисе, миграции EF Core, YARP-шлюз, удобный доступ к RabbitMQ-UI
